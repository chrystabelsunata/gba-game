#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"
#include "images/peachcircuit.h"
#include "images/mariokart.h"
#include "images/winscreen.h"
#include "images/coin.h"
#include "images/turtleshell.h"



/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;


  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Initialize struct mario
  struct mario mario;
  mario.row = 80;
  mario.col = 0;
  struct mario *marioPointer = &mario;

  struct coin coins;
  struct coin *coinsPointer = &coins;

  struct turtle turtle;
  turtle.row = 0;
  turtle . col = 240;
  struct turtle *turtlePointer = &turtle;

  // Load initial application state
  int time = 30;
  enum gba_state state = START;
  int startDrawn = 0;
  int winDrawn = 0;
  int loseDrawn = 0;

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state) {
      case START:
        waitForVBlank();
        if (startDrawn == 0) {
          drawFullScreenImageDMA(peachcircuit);
          drawString(110, 50, "Welcome to Mario Kart!", BLUE);
          drawString(130, 55, "Press START to play", BLUE);
          startDrawn = 1;
        }
        if (KEY_DOWN(BUTTON_START, currentButtons)) {
          turtlePointer-> row = 0;
          turtlePointer-> col = 240;
          turtlePointer-> rowDisplacement = 1;
          turtlePointer-> colDisplacement = 1;
          turtlePointer -> width = 10;
          turtlePointer -> height = 11;

          marioPointer-> row = 80;
          marioPointer-> col = 0;
          marioPointer-> width = 10;
          marioPointer-> height = 11;

          coinsPointer-> row = 80;
          coinsPointer-> col = 230;
          coinsPointer-> width = 10;
          coinsPointer-> height = 11;
          
          vBlankCounter = 0;
          state = PLAY;
        }
        // state = ?
        break;
      case PLAY:
        turtlePointer->row = turtlePointer->row + turtlePointer->rowDisplacement;
        turtlePointer->col = turtlePointer->col + turtlePointer->colDisplacement;

        // if turtle hits top border
        if (turtlePointer-> row < 0) {
          turtlePointer-> row = 160;
        }

        // if turtle hits bottom border
        if (turtlePointer-> row > 160) {
          turtlePointer-> row = 0;
        }

        // if turtle hits left border
        if (turtlePointer-> col < 0) {
          turtlePointer-> col = 240;
        }

        // if turtle hits right border
        if (turtlePointer-> col > 240) {
          turtlePointer-> col = 0;
        }


        time = 30 - vBlankCounter / 60;
        waitForVBlank();
        fillScreenDMA(BLACK);
        drawImageDMA(coinsPointer-> row,  coinsPointer-> col,  coinsPointer-> width,  coinsPointer-> height, coin);
        drawImageDMA(turtlePointer-> row, turtlePointer-> col, turtlePointer-> width, turtlePointer-> height, turtleshell);

        // Draw Mario image and its movements
        drawImageDMA(marioPointer-> row,  marioPointer-> col,  marioPointer-> width,  marioPointer-> height, mariokart);
        
        if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
          if (marioPointer->col >= WIDTH - marioPointer->width) {
            marioPointer->col = WIDTH - marioPointer->width;
          } else {
            marioPointer->col = marioPointer-> col + 1;
          }
        }
        if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
          if (marioPointer->col <= 0) {
            marioPointer->col = 0;
          } else {
            marioPointer->col = marioPointer-> col - 1;
          }
        }
        if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
          if (marioPointer->row >= 145 - marioPointer->height) {
            marioPointer->row = 145 - marioPointer->height;
          } else {
            marioPointer->row = marioPointer->row + 1;
          }
        }
        if (KEY_DOWN(BUTTON_UP, currentButtons)) {
          if (marioPointer->row <= 0) {
            marioPointer->row = 0;
          } else {
            marioPointer->row = marioPointer->row - 1;
          }
        }
        drawImageDMA(marioPointer-> row,  marioPointer-> col,  marioPointer-> width,  marioPointer-> height, mariokart);

        char buffer[51];
        sprintf(buffer, "Timer: %d", time);
        drawString(150, 5, buffer, YELLOW);

        // state = ?
        // if Mario's right side collides with coin
        if ((marioPointer-> col + marioPointer-> width) == coinsPointer-> col) {
          if (marioPointer-> row <= coinsPointer-> row && marioPointer-> row + marioPointer-> height >= coinsPointer-> row) {
            winDrawn = 0;
            state = WIN;
          }
          if (marioPointer-> row >= coinsPointer-> row && marioPointer-> row - marioPointer-> height <= coinsPointer-> row) {
            winDrawn = 0;
            state = WIN;
          }  
        }
       
        //if Mario's bottom side collides with coin
        if (
          (marioPointer-> row + marioPointer-> height) == coinsPointer-> row &&
          marioPointer-> col + marioPointer-> width >= coinsPointer-> col
        ) {
          winDrawn = 0;
          state = WIN;
        }

        //if Mario's top side collides with coin
        if (
          marioPointer-> row - marioPointer-> height == coinsPointer-> row &&
          marioPointer-> col + marioPointer-> width >= coinsPointer-> col
        ) {
          winDrawn = 0;
          state = WIN;
        }

        // if Mario's bottom side collides with turtle
        if (
          (marioPointer-> row + marioPointer-> height) == turtlePointer-> row &&
          marioPointer-> col < turtlePointer-> col &&
          marioPointer-> col + marioPointer-> width > turtlePointer-> col
        ) {
          loseDrawn = 0;
          state = LOSE;
        }

        // if Mario's top side collides with turtle
        if (
          marioPointer-> row - marioPointer-> height == turtlePointer-> row &&
          marioPointer-> col < turtlePointer-> col &&
          marioPointer-> col + marioPointer-> width > turtlePointer-> col
        ) {
          loseDrawn = 0;
          state = LOSE;
        }

        // if Mario's left side collides with turtle
        if (
          marioPointer-> col == turtlePointer -> col &&
          marioPointer-> row < turtlePointer-> row &&
          marioPointer-> row + marioPointer->height > turtlePointer-> row
        ) {
          loseDrawn = 0;
          state = LOSE;
        }

        // if Mario's right side collides with turtle
        if (
          marioPointer-> col + marioPointer-> width == turtlePointer -> col &&
          marioPointer-> row < turtlePointer-> row &&
          marioPointer-> row + marioPointer->height > turtlePointer-> row
        ) {
          loseDrawn = 0;
          state = LOSE;
        }
        if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
          startDrawn = 0;
          state = START;
        }

        if (time == 0) {
          loseDrawn = 0;
          state = LOSE;
        }
        break;
        
      case WIN:
        waitForVBlank();
        if (winDrawn == 0) {
          drawFullScreenImageDMA(winscreen);
          drawString(30, 15, "YOU WIN!", GREEN);
          drawString(70, 15, "PRESS BACK TO PLAY AGAIN", GREEN);
          winDrawn = 1;
        }
        // state = ?
        if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
          startDrawn = 0;
          state = START;
        }
        break;
      case LOSE:
      waitForVBlank();
      if (loseDrawn == 0) {
        fillScreenDMA(GRAY);
        drawString(50, 15, "YOU LOSE!", WHITE);
        drawString(130, 15, "PRESS BACK TO PLAY AGAIN", WHITE);
        loseDrawn = 1;
      }

      //drawFullScreenImage and drawString
      if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
        startDrawn = 0;
        state = START;
      }
        // state = ?
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}
